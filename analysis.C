 #include "TROOT.h"
 #include "TFile.h"
 #include "TTree.h"
 #include "TCut.h"
 #include "TBrowser.h"
 #include "TH2.h"
 #include "TRandom.h"
 #include <vector>
 #include <iostream>
 #include "TString.h"
 #include <string>
 
 #include <algorithm> // std::sort, std::copy
 #include <iterator> // std::ostream_iterator
 #include <sstream> // std::istringstream
 #include <cctype> // std::isdigit
using namespace std;

float tree_reader(string filename)
 {
    //read the Tree generated by tree1w and fill two histograms
  
    //note that we use "new" to create the TFile and TTree objects !
    //because we want to keep these objects alive when we leave this function.
    TFile *f = new TFile(filename.c_str());
    TTree *outTree = (TTree*)f->Get("outTree");
    Double_t Ener1;
    outTree->SetBranchAddress("Ener1",&Ener1);

    TH1F *E = new TH1F("Energy","Energy distribution ",50,656,666);
    
  
    //read all entries and fill the histograms
    Long64_t nentries = outTree->GetEntries();
    for (Long64_t i=0;i<nentries;i++) {
      outTree->GetEntry(i);
      E->Fill(Ener1);
   }

    TF1  *f1 = new TF1("f1","gaus",656,666);
    //f1->SetParameter(1,1000);
    E->Fit("f1");
    E->Draw();
    E->GetXaxis()->SetRangeUser(656, 666);
    float area = f1->Integral(656,666)*5; //moltiplicare per il numero di bin per unitÃ  di energia
	
   //E->Draw();

   //we do not close the file. We want to keep the generated histograms
   //we open a browser and the TreeViewer
   //if (gROOT->IsBatch()) return;
   //new TBrowser();
   //qtree->StartViewer();
   // in the browser, click on "ROOT Files", then on "tree1.root".
   // you can click on the histogram icons in the right panel to draw them.
   // in the TreeViewer, follow the instructions in the Help button.
  
   // Allow to use the TTree after the end of the function.
   outTree->ResetBranchAddresses();
   return round(area); 
 }


bool startsWith(string mainStr, string toMatch)
{
    // std::string::find returns 0 if toMatch is found at starting
    if(mainStr.find(toMatch) == 0)
        return true;
    else
        return false;
}

/*vector<float> loop_analysis(const char *dirname, const char *ext=".root")
{
   vector<float> results_vector; 
   TSystemDirectory dir(dirname, dirname);
   TList *files = dir.GetListOfFiles();
   if (files) {
      TSystemFile *file;
      TString fname;
      TIter next(files);
      while ((file=(TSystemFile*)next())) {
         fname = file->GetName();
         if (!file->IsDirectory() && fname.EndsWith(ext) && startsWith(fname.Data(),"g4") == true) { 
            float peak_area = tree_reader(fname.Data()); 
	    //cout<<fname.Data()<<endl;
	    //cout<<peak_area<<endl;
            results_vector.push_back(peak_area);
         }
      }
   }
    return results_vector;
}*/

vector<string> list_file_in_dir(const char *dirname, const char *ext=".root")
{
   vector<string> list_files; 
   TSystemDirectory dir(dirname, dirname);
   TList *files = dir.GetListOfFiles();
   if (files) {
      TSystemFile *file;
      TString fname;
      TIter next(files);
      while ((file=(TSystemFile*)next())) {
         fname = file->GetName();
         if (!file->IsDirectory() && fname.EndsWith(ext)) {  
	    //cout<<fname.Data()<<endl;
            list_files.push_back(fname.Data());
         }
      }
   }
    return list_files;
}


/*void print(std::vector<float> const &results)
{
	
    for (int i = 0; i < results.size(); i++) {
         cout << results.at(i) << ' ';
    }
}*/

vector<float> loop_analysis(vector<string> sorted_list)
{
    vector<float> results_vector;
    for (int i = 0; i < sorted_list.size(); i++) {
         string file_name = sorted_list.at(i);
    	 float peak_area = tree_reader(file_name);
         results_vector.push_back(peak_area);
	 cout<< "processing: "<<file_name;
    }
    return results_vector;
}


bool compareNat(const std::string& a, const std::string& b)
{
    if (a.empty())
        return true;
    if (b.empty())
        return false;
    if (std::isdigit(a[0]) && !std::isdigit(b[0]))
        return true;
    if (!std::isdigit(a[0]) && std::isdigit(b[0]))
        return false;
    if (!std::isdigit(a[0]) && !std::isdigit(b[0]))
    {
        if (std::toupper(a[0]) == std::toupper(b[0]))
            return compareNat(a.substr(1), b.substr(1));
        return (std::toupper(a[0]) < std::toupper(b[0]));
    }

    // Both strings begin with digit --> parse both numbers
    std::istringstream issa(a);
    std::istringstream issb(b);
    int ia, ib;
    issa >> ia;
    issb >> ib;
    if (ia != ib)
        return ia < ib;

    // Numbers are the same --> remove numbers and recurse
    std::string anew, bnew;
    std::getline(issa, anew);
    std::getline(issb, bnew);
    return (compareNat(anew, bnew));
}


void analysis() 
{
    int number_of_layers;
    cout<< "insert number of layers: " <<endl;
    cin>>number_of_layers;
    
    vector<string> list_of_files;
    char *working_dir_path = realpath(".", NULL);
    list_of_files = list_file_in_dir(working_dir_path);
    
    sort(list_of_files.begin(), list_of_files.end(),compareNat);
    
    vector<float> results;
    results = loop_analysis(list_of_files);
    ofstream outFile("results.txt");
    for (int i = 0; i < results.size(); i++) {
    	if (i%number_of_layers == 0){
    		outFile << "\n" << results.at(i);
		}
   	 else {
	  	outFile << "," << results.at(i);
  		}
	}
    outFile.close();
}

